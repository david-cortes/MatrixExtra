% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matmul.R
\name{matmult}
\alias{matmult}
\alias{\%*\%,matrix,CsparseMatrix-method}
\alias{\%*\%,float32,CsparseMatrix-method}
\alias{tcrossprod,matrix,RsparseMatrix-method}
\alias{tcrossprod,float32,RsparseMatrix-method}
\alias{crossprod,matrix,CsparseMatrix-method}
\alias{crossprod,float32,CsparseMatrix-method}
\alias{\%*\%,RsparseMatrix,matrix-method}
\alias{\%*\%,RsparseMatrix,float32-method}
\alias{tcrossprod,RsparseMatrix,matrix-method}
\alias{tcrossprod,RsparseMatrix,float32-method}
\alias{\%*\%,RsparseMatrix,numeric-method}
\alias{\%*\%,RsparseMatrix,logical-method}
\alias{\%*\%,RsparseMatrix,integer-method}
\alias{\%*\%,RsparseMatrix,sparseVector-method}
\title{Multithreaded Sparse-Dense Matrix and Vector Multiplications}
\usage{
\S4method{\%*\%}{matrix,CsparseMatrix}(x, y)

\S4method{\%*\%}{float32,CsparseMatrix}(x, y)

\S4method{tcrossprod}{matrix,RsparseMatrix}(x, y)

\S4method{tcrossprod}{float32,RsparseMatrix}(x, y)

\S4method{crossprod}{matrix,CsparseMatrix}(x, y)

\S4method{crossprod}{float32,CsparseMatrix}(x, y)

\S4method{\%*\%}{RsparseMatrix,matrix}(x, y)

\S4method{\%*\%}{RsparseMatrix,float32}(x, y)

\S4method{tcrossprod}{RsparseMatrix,matrix}(x, y)

\S4method{tcrossprod}{RsparseMatrix,float32}(x, y)

\S4method{\%*\%}{RsparseMatrix,numeric}(x, y)

\S4method{\%*\%}{RsparseMatrix,logical}(x, y)

\S4method{\%*\%}{RsparseMatrix,integer}(x, y)

\S4method{\%*\%}{RsparseMatrix,sparseVector}(x, y)
}
\arguments{
\item{x, y}{dense (\code{matrix} / \code{float32})
and sparse (\code{RsparseMatrix} / \code{CsparseMatrix}) matrices.}
}
\value{
A dense \code{matrix} object.
}
\description{
Multithreaded <matrix, matrix> multiplications
(`\%*\%`, `crossprod`, and `tcrossprod`)
and <matrix, vector> multiplications (`\%*\%`),
for <sparse, dense> matrix combinations and <sparse, vector> combinations
(See signatures for supported combinations).

Objects from the `float` package are also supported for some combinations.
}
\details{
Be aware that sparse-dense matrix multiplications might suffer from reduced
numerical precision, especially when using objects of type `float32`
(from the `float` package).

When multiplying a sparse matrix by a sparse vector, their indices
will be sorted in-place (see \link{sort_sparse_indices}).
}
\examples{
library(Matrix)
library(MatrixExtra)
## Will use the same number of threads as for BLAS
curr_nthreads <- RhpcBLASctl::blas_get_num_procs()
## Set the number of threads here (will restore later)
RhpcBLASctl::blas_set_num_threads(1L)

## Generate random matrices
set.seed(1)
A <- rsparsematrix(5,4,.5)
B <- rsparsematrix(4,3,.5)

## Now multiply in some supported combinations
as.matrix(A) \%*\% as.csc.matrix(B)
as.csr.matrix(A) \%*\% as.matrix(B)
crossprod(as.matrix(B), as.csc.matrix(B))
tcrossprod(as.csr.matrix(A), as.matrix(A))

## Restore the number of threads for BLAS
RhpcBLASctl::blas_set_num_threads(curr_nthreads)
}
